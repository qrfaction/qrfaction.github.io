<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="qrfaction的博客">
<meta property="og:url" content="https://github.com/qrfaction/qrfaction.github.io/index.html">
<meta property="og:site_name" content="qrfaction的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qrfaction的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/qrfaction/qrfaction.github.io/"/>





  <title>qrfaction的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ce10a2762e71d0513ae5a919b9cf34a5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qrfaction的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/06/01/并行数据处理库Dask介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/并行数据处理库Dask介绍/" itemprop="url">并行数据处理库Dask介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T20:13:39+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高性能编程/" itemprop="url" rel="index">
                    <span itemprop="name">高性能编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有一些临时需求需要并行一些python代码<br>受限于multiprocessing的进程通信限制,不能很方便的通信大矩阵…</p>
<p>今天偶然发现一个Dask库<br>api与numpy,pandas一致,但可以并行计算<br>真的是雪中送炭hh</p>
<h2 id="Dask"><a href="#Dask" class="headerlink" title="Dask"></a>Dask</h2><h3 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h3><p>High Level</p>
<blockquote>
<p>  Arrays: 并行Numpy<br>    Bags: 并行lists<br>    Dataframes: 并行Pandas<br>    Machine Learning : 并行Scikit-Learn<br>    Others from external projects, like XArray</p>
</blockquote>
<p>Low Level</p>
<blockquote>
<p>  Delayed: 用这个装饰器可以用于封装自定义函数来搭建计算图延迟计算<br>    Futures: real-time parallel function evaluation</p>
</blockquote>
<h3 id="计算图搭建与延迟计算"><a href="#计算图搭建与延迟计算" class="headerlink" title="计算图搭建与延迟计算"></a>计算图搭建与延迟计算</h3><p>方式一</p>
<blockquote>
<p>import dask</p>
</blockquote>
<p>lazy_results = []<br>for a in A:<br>&emsp;&emsp;for b in B:<br>&emsp;&emsp;&emsp;&emsp;if a &lt; b:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c = dask.delayed(f)(a, b)  # 延迟任务计算,f是自定义函数<br>&emsp;&emsp;&emsp;&emsp;else:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c = dask.delayed(g)(a, b)  # 延迟任务计算<br>&emsp;&emsp;&emsp;&emsp;lazy_results.append(c)</p>
<blockquote>
<p>results = dask.compute(*lazy_results)  # 并行计算所有任务</p>
</blockquote>
<p>方式二 </p>
<blockquote>
</blockquote>
<p>@dask.delayed<br>def inc(x):<br>&emsp;&emsp;return x + 1</p>
<blockquote>
</blockquote>
<p>@dask.delayed<br>def add(x, y):<br>&emsp;&emsp;return x + y</p>
<blockquote>
</blockquote>
<p>a = inc(1)       # 放入计算图<br>b = inc(2)       # 放入计算图<br>c = add(a, b)    # 放入计算图</p>
<blockquote>
</blockquote>
<p>c = c.compute()  # 运行计算图并返回结果</p>
<h3 id="Dask中的pandas一览"><a href="#Dask中的pandas一览" class="headerlink" title="Dask中的pandas一览"></a>Dask中的pandas一览</h3><blockquote>
</blockquote>
<p>>&gt;&gt; import dask.dataframe as dd<br>>&gt;&gt; df = dd.read_csv(‘2014-*.csv’)<br>>&gt;&gt; df.head()<br>&emsp;&emsp;&ensp;x&emsp;y<br>&emsp;0&emsp;1&emsp;a<br>&emsp;1&emsp;2&emsp;b<br>&emsp;2&emsp;3&emsp;c<br>&emsp;3&emsp;4&emsp;a<br>&emsp;4&emsp;5&emsp;b<br>&emsp;5&emsp;6&emsp;c</p>
<blockquote>
</blockquote>
<p>>&gt;&gt; df2 = df[df.y == ‘a’].x + 1</p>
<blockquote>
</blockquote>
<p>>&gt;&gt; df2.compute()<br>0&emsp;2<br>3&emsp;5<br>Name: x, dtype: int64</p>
<p>pandas中如下等各类函数皆被加速处理</p>
<p>dd.merge(df1, df2, on=’name’)<br>df.groupby(df.x).apply(myfunc)<br>df[df.x &gt; 0]<br>df.x + df.y<br>等等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/31/人脑核磁共振海马体分割竞赛总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/人脑核磁共振海马体分割竞赛总结/" itemprop="url">人脑核磁共振海马体分割竞赛总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T21:49:37+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据竞赛/" itemprop="url" rel="index">
                    <span itemprop="name">数据竞赛</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最终结果是进决赛拿了二等奖<br>话说一等奖分数比我低很多诶,凭啥他一等= =<br>这个比赛其实从头水到尾,都没干啥事…<br>不过还是挑一些重点的有价值的东西讲讲<br>很多比赛总结其实一直好像是一个比较流水线的报告<br>从预处理到最后的集成<br>即便trick百出,仍似千篇一律</p>
<p>但我仍然喜欢有人能相对于trick提出更多的问题</p>
<p>下面只讲一下个人感觉有价值的东西<br>就不千篇一律的从数据预处理数据增强的一步步介绍了</p>
<h3 id="比赛介绍"><a href="#比赛介绍" class="headerlink" title="比赛介绍"></a>比赛介绍</h3><p>这个比赛是一个3D医学图像分割问题<br>目标是对大脑中的左右海马体进行分割</p>
<h3 id="数据特点"><a href="#数据特点" class="headerlink" title="数据特点"></a>数据特点</h3><p>132组样本<br>3D图像,4D张量,5D一个batchsize<br>十分吃显存<br>卷积核数稍微大一点就给你爆0.1T显存</p>
<p>训练不稳定<br>模型对海马体的差异十分敏感,不同的海马体dice loss差距对比有0.85 , 0.42</p>
<p>验证集阈值浮动<br>由于模型对海马体差异十分敏感<br>所以所以验证集分数经常会从几十跳成0</p>
<p>海马体强度不均<br>一些海马体体素强度在0至200的范围,部分在0至两千的范围</p>
<h3 id="问题的解决方式"><a href="#问题的解决方式" class="headerlink" title="问题的解决方式"></a>问题的解决方式</h3><p>吃显存是真的没法子了<br>只能减通道数<br>毕竟换tesla P40是不可能的,这辈子都不可能换的<br>写插值压小图片又不想写,只能随随便便改改卷积核数才适合我</p>
<p>训练不稳定和验证集阈值浮动提供几个很棒的解决方案</p>
<ol>
<li>改batchsize<br> 将batchsize设置为8问题就被缓解很多了,简单粗暴,但要牺牲一些通道数</li>
<li>将sigmoid激活改成tanh + score map MinMax归一化 + diceLoss<br> 这个方式超级显著,可以说完全解决了这个问题,小batchsize大概要几千轮的样子才能让loss和验证集稳定<br> 这个配合8 batchsize在仅仅600轮即可收敛到88的分数<br> score map MinMax归一化是利用了图片中必定存在海马体的先验信息,即必定存在正例体素</li>
<li>一堆后处理trick(基于梯度,类间方差,类内方差,knn+先验等<br> 在这里我创了很多方法,这个方法有点慢,效果是有的,不如2+1</li>
<li>ConvLSTM<br> 将3D图片的一个轴作为循环轴,利用循环单元拟合,这种结构契合了海马体的形态变化<br> 这个结构分数真的很稳,鲁棒性棒棒哒</li>
<li>在像素级的任务中尽量少用Pool,因为像素级的不对齐任务似乎还是有点影响的</li>
</ol>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>其他的事不想说了,毕竟水过来的,很不认真hh<br>一些数据增强,预处理都不想说了<br>我的几个模型结构也懒得聊,看多了只觉得模型结构要么是拍脑袋拿到的,要么是暴力搜素<br>毕竟缺乏理论性,马后炮事的分析结构是很抗拒的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/29/CUDA上下文环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/29/CUDA上下文环境/" itemprop="url">CUDA上下文环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T14:51:15+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高性能编程/" itemprop="url" rel="index">
                    <span itemprop="name">高性能编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇博客为高性能CUDA应用设计与开发第七章阅读笔记</p>
<h2 id="CUDA上下文环境"><a href="#CUDA上下文环境" class="headerlink" title="CUDA上下文环境"></a>CUDA上下文环境</h2><h4 id="cuda上下文环境"><a href="#cuda上下文环境" class="headerlink" title="cuda上下文环境"></a>cuda上下文环境</h4><p>囊括了所必需的驱动状态信息,如虚拟地址空间,流,事件,已分配的内存块等</p>
<h4 id="GPU设备与上下文"><a href="#GPU设备与上下文" class="headerlink" title="GPU设备与上下文"></a>GPU设备与上下文</h4><p>GPU设备驱动通过设备驱动程序为应用程序提供多个上下文环境<br>就可以使单个CUDA应用程序使用多个设备</p>
<p>同一时刻只能有一个上下文环境处于活动状态<br>所以需要操作多个设备时,需要用cudasetDevice()切换上下文环境</p>
<p>cuda在第一次调用一个改变驱动状态的函数时会自动默认创建一个上下文环境<br>如cudaMalloc()<br>默认在 GPU 0 上创建上下文</p>
<h4 id="上下文与流"><a href="#上下文与流" class="headerlink" title="上下文与流"></a>上下文与流</h4><p>cuda程序通过将操作排队到流中,管理任务和并行<br>创建上下文时会隐式的创建一个流,从而命令可以在设备中排队等待执行<br>cudaMemcpy ,kernel函数等都会自动放入默认流中串行执行</p>
<p>除非指定不同的流,kernel函数流的指定如下<br>kernel&lt;&lt;&lt;nBlocks, nThreadsPerBlocks, 0,stream&gt;&gt;&gt;(para)<br>第三个可填参数是共享内存大小的分配</p>
<p>当kernel函数之间需要并发执行时要使用多个流</p>
<h2 id="任务并发与同步"><a href="#任务并发与同步" class="headerlink" title="任务并发与同步"></a>任务并发与同步</h2><h3 id="显式同步"><a href="#显式同步" class="headerlink" title="显式同步"></a>显式同步</h3><p>cudaEventRecord()<br>我的理解是他是往当前流中异步发送了一个任务(记录时间)<br>由于同一个流中的顺序执行,使得他在之前的任务完成之后才能将传入的事件标记为完成</p>
<p>cudaStreamSynchronize() //同步流与cpu线程<br>cudaDeviceSynchronize() //在cpu线程中同步所有流<br>cudaStreamWaitEvent()   //等待某个事件结束后再执行该流上的任务(这个任务在cudaStreamWaitEvent调用之后指定)<br>cudaStreamQuery()       //查询一个流任务是否完成 </p>
<h3 id="隐式同步"><a href="#隐式同步" class="headerlink" title="隐式同步"></a>隐式同步</h3><p>部分主机操作在其完成前会强制所有流暂停执行<br>在使用下面这些主机操作时需注意,它们可能会停止所有的并发操作</p>
<ol>
<li>页锁定主机内粗的分配</li>
<li>设备内存的分配</li>
<li>设备内存设置</li>
<li>设备到设备的内存拷贝</li>
<li>L1缓存与共享内存之间的配置转换</li>
</ol>
<p>p.s. 我印象中内存的拷贝有异步api的</p>
<h3 id="同一GPU并发执行kernel注意事项"><a href="#同一GPU并发执行kernel注意事项" class="headerlink" title="同一GPU并发执行kernel注意事项"></a>同一GPU并发执行kernel注意事项</h3><p>运行多个kernel会改变索引的局部性<br>增加L2缓存的未命中率,甚至消除缓存的有效性<br>还会引入其他问题<br>如bank冲突和内存分区冲突</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>这部分书上主要讲了页锁定内存<br>感觉没另一本书讲的详细,之前博客写了不复述了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/27/multiprocessing神坑之进程通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/27/multiprocessing神坑之进程通信/" itemprop="url">multiprocessing神坑之进程通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-27T12:03:04+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高性能编程/" itemprop="url" rel="index">
                    <span itemprop="name">高性能编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>python的并发已经被诟病许久了<br>GIL锁导致线程级并发争用一个CPU<br>计算密集型任务在多线程的模式下根本做不到真正意义上的并发<br>导致python的多线程只适用于非计算密集型任务类似I/O等</p>
<p>避开这个劣势一般有两种策略<br>其一是使用multiprocessing将线程级转到进程级<br>其二便是使用C语言</p>
<h2 id="multiprocessing的进程通信方式"><a href="#multiprocessing的进程通信方式" class="headerlink" title="multiprocessing的进程通信方式"></a>multiprocessing的进程通信方式</h2><p>multiprocessing开启一个子进程,两者传参的通信方式是使用pickle将参数序列化</p>
<p>pickle是一种python自带的对象序列化方法,类似json<br>不同之处</p>
<ol>
<li>pickle是python专有,json是通用型序列化方法</li>
<li>pickle编码方式是二进制,便于I/O以及传输,而json可读性较高I/O方面速度较慢</li>
<li>json只能序列化python中的部分对象,而pickle可以序列化大多数</li>
</ol>
<p>在python中使用进程并发时隐藏了这些细节<br>但实际中他是以pickle进行传输数据<br>这就带来了下面的问题</p>
<h2 id="multiprocessing的进程通信限制"><a href="#multiprocessing的进程通信限制" class="headerlink" title="multiprocessing的进程通信限制"></a>multiprocessing的进程通信限制</h2><blockquote>
<p>struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647</p>
</blockquote>
<p>这是我将一个比较大的矩阵作为参数进行传输时带来的问题</p>
<p>其实一个空间占用极大的对象理当不该作为参数传输<br>但是进程不像线程没有共享内存的空间诶,写细了很麻烦<br>再次diss一下Python的并发</p>
<p>这个是触发了多进程中pickle中序列化大小的限制<br>对象过大无法被序列化  = =</p>
<p>如果一些特殊条件导致不方便直接在硬盘上I/O<br>还有什么方法给一个进程传送存储量大的数据呢</p>
<h2 id="multiprocessing的进程的共享对象"><a href="#multiprocessing的进程的共享对象" class="headerlink" title="multiprocessing的进程的共享对象"></a>multiprocessing的进程的共享对象</h2><p>进程的原则本是尽量避免数据共享…<br>但有些情况下又不好避免<br>理当当断则断</p>
<p>multiprocessing中实现了很多用于进程间数据共享的对象<br>如Queue, Array, Value, NameSpace等等</p>
<p>这些对象共享数据的方式是用过创建一个服务进程<br>然后其他进程访问相关数据的某部分时<br>服务进程将这部分数据序列化传输给该进程</p>
<p>这就达到了分批传输的方式</p>
<p>我们这里介绍一个Manager的对象管理方式</p>
<p>创建数据server进程以及给worker进程分配任务</p>
<blockquote>
<p>  with Manager() as manager :<br>    &emsp; &emsp;dataset = manager.list()<br>    &emsp; &emsp;dataset.append(matrix)<br>    &emsp; &emsp;…<br>    &emsp; &emsp;pool.apply_async(worker,args=( dataset, other para))</p>
</blockquote>
<p>worker进程中使用数据</p>
<blockquote>
<p>  def worker(dataset, other para):<br>    &emsp; &emsp;matrix1 = dataset[0]<br>    &emsp; &emsp;matrix2 = dataset[1]<br>    &emsp; &emsp; …</p>
</blockquote>
<p>这与一般的list不同之处在于<br>manager的list对象的数据访问是从server进程上访问的<br>dataset.append(matrix) 通过这行代码将数据分批放入server进程中<br>再在worker进程中 matrix1 = dataset[0] 分批取出</p>
<p>即可避免了过大的数据无法序列化的问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/25/Process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/25/Process/" itemprop="url">Dynamic Network Embedding by Modeling Triadic Closure Process阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-25T21:51:55+08:00">
                2018-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Representation-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Representation Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Network embedding 是表示学习中很重要的一块<br>著名的算法有node2vec,line,SDNE,svd等等<br>这篇论文提出的模型主要是对社交网络中的三角闭包结构和社交网络的时间动态变化建模</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>点集 V = {  v<sub>1</sub>,v<sub>2</sub>,…,v<sub>M</sub> }<br>边集 E = {  e<sub>ij</sub> }  </p>
<p>动态网络 G = { G<sup>1</sup>,G<sup>2</sup>,…,G<sup>T</sup>}<br>G<sup>t</sup> = ( V , E<sup>t</sup> , W<sup>t</sup> ) 表示每个时间段的网络图,W<sup>t</sup>是权重<br>u<sup>t</sup><sub>i</sub> = f<sup>t</sup>(v<sub>i</sub>)  表示学习到的结点v<sub>i</sub>向量 </p>
<h2 id="Triadic-closure-process-三元闭包过程"><a href="#Triadic-closure-process-三元闭包过程" class="headerlink" title="Triadic closure process 三元闭包过程"></a>Triadic closure process 三元闭包过程</h2><p>以社交网络为例<br>( v<sub>i</sub>,v<sub>j</sub>,v<sub>k</sub>)在某时间段是个(open traid)开三角<br>即i,j互不认识,但k认识他俩<br>三元闭包过程就是以预测下一个时间段i,j会相识的概率<br>这个概率取决于k与他们的亲密程度<br>一般来讲越亲密越容易介绍他俩彼此相识<br>亲密程度建模如下,w为权重</p>
<p><img src="http://latex.codecogs.com/gif.latex?x%5Et_%20%7Bijk%7D%20%3D%20w%5Et_%20%7Bik%7D%20*%20%28%20u%5Et_%20%7Bk%7D%20-%20u%5Et_%20%7Bi%7D%20%29%20-%20w%5Et_%20%7Bjk%7D%20*%20%28%20u%5Et_%20%7Bk%7D%20-%20u%5Et_%20%7Bj%7D%29" alt=""></p>
<p>其中下个时间段相识的概率为<br><img src="http://latex.codecogs.com/gif.latex?x%5Et_%20%7Bijk%7D%20%3D%20w%5Et_%20%7Bik%7D%20*%20%28%20u%5Et_%20%7Bk%7D%20-%20u%5Et_%20%7Bi%7D%20%29%20-%20w%5Et_%20%7Bjk%7D%20*%20%28%20u%5Et_%20%7Bk%7D%20-%20u%5Et_%20%7Bj%7D%29" alt=""></p>
<p>极大似然估计<br><img src="http://latex.codecogs.com/gif.latex?%28P%5Et_%7Btr%7D%28i%2Cj%2Ck%29%29%5E%7B%5Calpha_%7Bk%7D%5E%7Bt%2Cj%2Ck%7D%20%7D%20*%20%281-P%5Et_%7Btr%7D%28i%2Cj%2Ck%29%29%29%5E%7B1-%5Calpha_%7Bk%7D%5E%7Bt%2Cj%2Ck%7D%7D" alt=""><br>α<sub>ijk</sub><sup>t</sup> 为label ,下一时刻( v<sub>i</sub>,v<sub>j</sub>,v<sub>k</sub>)为(close traid)闭三角则为1,反之为0</p>
<p>再遍历所有open traid的样本组累乘概率进行极大似然估计<br>loss函数为<br><img src="http://latex.codecogs.com/gif.latex?L%5Et_%7Btr%7D%20%3D-%20%5Csum_%7B%28i%2Cj%29%5Cin%20S_&plus;%7DlogP%5Et_%7Btr&plus;%7D%28i%2Cj%29%20-%20%5Csum_%7B%28i%2Cj%29%5Cin%20S_-%7DlogP%5Et_%7Btr-%7D%28i%2Cj%29" alt=""><br>S<sub>+</sub>  是下一段时刻会变成close traid的样本组集合<br>S<sub>-</sub>  相反</p>
<h2 id="Social-homophily"><a href="#Social-homophily" class="headerlink" title="Social homophily"></a>Social homophily</h2><p><img src="http://latex.codecogs.com/gif.latex?L%5Et_%7Bsh%7D%20%3D%20%5Csum_%7B%28i%2Cj%29%5Cin%20E%5Et_&plus;%20%2C%20%28i%5E%7B%27%7D%2Cj%5E%7B%27%7D%29%20%5Cin%20E%5Et_-%7Dh%28w_%7Bj%2Ck%7D%2C%5Bg%5Et%28j%2Ck%29%20-%20g%5Et%28j%5E%7B%20%27%7D%2Ck%5E%7B%27%7D%29%20&plus;%20%5Cxi%20%5D_&plus;%20%29" alt=""><br>E<sup>t</sup><sub>-</sub> 为E<sup>t</sup>中不存在的边<br>h(w,x) = wx<br>[ x ]<sub>+</sub> = max(0,x)<br>该loss即使用了 tripet loss 期望近邻结点相似,非近邻结点稍远</p>
<h2 id="Temporal-smoothness"><a href="#Temporal-smoothness" class="headerlink" title="Temporal smoothness"></a>Temporal smoothness</h2><p><img src="http://latex.codecogs.com/gif.latex?%24%24%20L%5Et_%7Bsmooth%7D%20%3D%20%5Cbegin%7Bcases%7D%20%5Csum%5EN_%7Bi%3D1%7D%20%7C%7C%20u%5Et_i%20-%20u%5E%7Bt-1%7D_i%20%7C%7C%20%26%20t%3E1%20%5C%5C%200%20%26%20t%3D1%20%5Cend%7Bcases%7D%24%24" alt=""></p>
<p>基于结点随时间的动态变化是平缓的猜想</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>最终三个loss加权求和即为最终loss</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/23/PCA实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/PCA实现/" itemprop="url">PCA实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-23T12:46:03+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于最近刚好由于要求写了一下PCA<br>其实还是很简单的<br>本篇介绍一个jacobi的方法</p>
<p>令X样本集,行向量为样本,列向量为特征</p>
<ol>
<li><p>先对X的特征进行中心化, 即每一列特征减去其期望(均值)</p>
</li>
<li><p>奇异值分解</p>
<p> X = U<sub>n,n</sub> Σ<sub>n,m</sub> V<sup>T</sup><sub>m,m</sub><br> 选取奇异值最大的 k 个主成分,即<br> X ≈ U<sub>n,k</sub> Σ<sub>k,k</sub> V<sup>T</sup><sub>k,m</sub><br> &lt;=&gt;<br> X V<sub>m,k</sub> ≈ U<sub>n,k</sub> Σ<sub>k,k</sub> </p>
<p> 其中U<sub>n,k</sub> Σ<sub>k,k</sub> 即为X的低维空间投影<br> V<sub>m,k</sub>为降维矩阵<br> 至此PCA过程就结束了</p>
</li>
<li><p>特征值分解与奇异值分解</p>
<p> X<sup>T</sup>X = P λ P<sup>T</sup> = V Σ<sup>T</sup>Σ V<sup>T</sup><br> 其中P是正交阵, λ 为特征值对角正阵, 特征值从大到小排序<br> 所以只需令P = V  , Σ<sup>T</sup>Σ = λ 即可<br> 再用U = Σ<sup>T</sup> V X 即可求出 U </p>
</li>
<li><p>计算特征向量</p>
<p> <img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/23/PCA实现/givens.jpeg" alt="这里写图片描述"><br> 基本想法是通过不断使用givens变换 (初等旋转变换) 将X的非对角元素变为0<br> P = ∏<sub>i</sub> P<sub>i</sub> (P<sub>i</sub> 是givens变换)<br> P<sup>T </sup>X<sup>T</sup>X P = λ<br> 其中P<sub>i</sub>中未知量的选取见下图<br> <img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/23/PCA实现/gi2.png" alt="这里写图片描述"><br> <img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/23/PCA实现/gi3.png" alt="这里写图片描述"> </p>
<p> 接着直至收敛<br> 接着将λ中的特征值从大到小排序,P中的特征向量依据λ的顺序进行排序<br> 从而得到了V</p>
<p> end  很简单hh  从头至尾就是一些矩阵乘法运算<br> givens和X的乘法只涉及到两行两列的元素故为O(n)的复杂度</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/19/IndRNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/IndRNN/" itemprop="url">IndRNN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T23:15:05+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DL/" itemprop="url" rel="index">
                    <span itemprop="name">DL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这些天的work和循环单元很相关<br>于是看了这篇很早就想看的IndRNN<br>不得不说work很好看<br>简单but略完美<br>传统循环单元一般只能坚持到几百步长<br>而他能坚持到5000!!!!!!</p>
<p>emmm<br>还有前天和鹏哥在微博上吹逼,吹错了<br>今天细看文章的时候发现的,真是尴尬hh</p>
<h3 id="IndRNN介绍"><a href="#IndRNN介绍" class="headerlink" title="IndRNN介绍"></a>IndRNN介绍</h3><p>IndRNN和传统RNN的定义式区别见下图</p>
<p>RNN<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/19/IndRNN/rnncell.jpeg" alt="这里写图片描述"><br>IndRNN<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/19/IndRNN/indrnn.jpeg" alt="这里写图片描述"> </p>
<p>整个区别真的只有矩阵乘法转为hadamard积(对应元素相乘)<br>其中每个h<sub>t</sub>使用的是不同的u向量权重<br>然后IndRNN一般采用relu激活<br>改动虽小,作用却大</p>
<h3 id="梯度分析传统RNN和IndRNN"><a href="#梯度分析传统RNN和IndRNN" class="headerlink" title="梯度分析传统RNN和IndRNN"></a>梯度分析传统RNN和IndRNN</h3><p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/19/IndRNN/rnn.jpeg" alt="这里写图片描述"><br>由梯度计算式可知传统RNN的连乘,由于这个原因导致了梯度爆炸和消失…<br>而再来观察IndRNN梯度的表达式<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/19/IndRNN/ind.jpeg" alt="这里写图片描述"><br>如果采用relu激活,后面部分的梯度连乘不会造成梯度爆炸<br>而u<sub>n</sub>的大小不会影响到h其他时间步的梯度<br>即由矩阵乘法转为hadamard积将梯度计算在一定程度上隔离开来了<br>u<sub>n</sub>是h<sub>n,t-1</sub>的权重而不会影响到其他时间步</p>
<p>而u只需约束到一个范围即可完美解决梯度消失与爆炸<br>见下图(其实我觉得没屁用,RNN不也可以这样吗)<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/19/IndRNN/const.jpg" alt="这里写图片描述"> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/14/2018CVPR之end2end光流相关滤波/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/2018CVPR之end2end光流相关滤波/" itemprop="url">2018CVPR之end2end光流相关滤波</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T16:10:57+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CV/" itemprop="url" rel="index">
                    <span itemprop="name">CV</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要使用了FlowNet和注意力机制利用了当前帧的上下文信息<br>里面的trick还是很多的</p>
<p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/model.jpeg" alt="这里写图片描述"> </p>
<h2 id="Historical-branch"><a href="#Historical-branch" class="headerlink" title="Historical branch"></a>Historical branch</h2><h3 id="FlowNet"><a href="#FlowNet" class="headerlink" title="FlowNet"></a>FlowNet</h3><p>详见我这篇文章<br><a href="https://qrfaction.github.io/2018/05/14/%E5%85%89%E6%B5%81%E4%BB%8B%E7%BB%8D%E4%B8%8EFlowNet/" target="_blank" rel="noopener">https://qrfaction.github.io/2018/05/14/%E5%85%89%E6%B5%81%E4%BB%8B%E7%BB%8D%E4%B8%8EFlowNet/</a></p>
<p><er></er></p>
<h3 id="Wrap操作"><a href="#Wrap操作" class="headerlink" title="Wrap操作"></a>Wrap操作</h3><h4 id="1-光流场的插值使用法"><a href="#1-光流场的插值使用法" class="headerlink" title="1.光流场的插值使用法"></a>1.光流场的插值使用法</h4><p>由光流定义可知 I<sub>t+1</sub>(x<sub>2</sub>,y<sub>2</sub>) = I<sub>t</sub>(x<sub>1</sub>+v<sub>x</sub>,y<sub>1</sub>+v<sub>y</sub>)<br>于是我们得到了一个像素间一一对应的关系<br>由于 (x<sub>1</sub>+v<sub>x</sub>,y<sub>1</sub>+v<sub>y</sub>) 可能是小数<br>所以需要使用双线性插值进行近似计算</p>
<p><er></er></p>
<h4 id="2-双线性插值嵌入layer"><a href="#2-双线性插值嵌入layer" class="headerlink" title="2.双线性插值嵌入layer"></a>2.双线性插值嵌入layer</h4><p>f(p) = ∑ W(p + δp) * f(p + δp)  &emsp;&emsp; p为位置(x,y)</p>
<p>其中 W(p + δp) 需要满足以下条件</p>
<ol>
<li>若 δp &lt; (1,1) , W(p + δp) = (1-δx) * (1-δy)</li>
<li>否则为0<br>这样就满足了双线性插值使用最近的四个点以及其权重两个条件</li>
</ol>
<p>W(p,q) = max(0,1-|p<sub>x</sub>-q<sub>x</sub>|) * max(0,1-|p<sub>y</sub>-q<sub>y</sub>|) = max(0,1 - δp<sub>x</sub>) * max(0,1 - δp<sub>y</sub>)</p>
<p><er></er></p>
<h4 id="3-历史信息封装"><a href="#3-历史信息封装" class="headerlink" title="3.历史信息封装"></a>3.历史信息封装</h4><p>将 I<sub>i</sub> 封装到 I<sub>t-1</sub> 操作的定义如下<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/wrap.jpeg" alt="这里写图片描述"><br>δp 是FlowNet输出的坐标偏移<br>K 是双线性插值权重函数<br>φ<sub>i</sub> 是第i帧图片经过FeatureNet后的特征图<br>m是φ<sub>i</sub>的第m个通道</p>
<p>这样即可利用双线性插值将 I<sub>i</sub> 的信息融入 I<sub>t-1</sub> 得到 φ<sub>i→t-1</sub></p>
<p><er></er></p>
<h3 id="Spatial-temporal-attention"><a href="#Spatial-temporal-attention" class="headerlink" title="Spatial-temporal attention"></a>Spatial-temporal attention</h3><h4 id="Spatial-attention"><a href="#Spatial-attention" class="headerlink" title="Spatial attention"></a>Spatial attention</h4><p>该注意力计算公式如下<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/attention.jpeg" alt="这里写图片描述"><br>使用余弦相似度得出了每个特征图中每个位置p的注意力权重<br>然后再使用softmax对所有历史帧中的p位置的注意力权重进行规范化</p>
<h4 id="temporal-attention"><a href="#temporal-attention" class="headerlink" title="temporal attention"></a>temporal attention</h4><p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/senet.jpeg" alt="这里写图片描述"><br>该注意力则是利用了类似SEnet中的模块的结构对时序轴进行加权<br>RASnet中的tracking也有用它</p>
<p><er></er></p>
<h3 id="计算φ-x"><a href="#计算φ-x" class="headerlink" title="计算φ(x)"></a>计算φ(x)</h3><p>定义如下<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/ux.jpeg" alt="这里写图片描述"><br>加权求和</p>
<p><er></er></p>
<h2 id="CFnet框架"><a href="#CFnet框架" class="headerlink" title="CFnet框架"></a>CFnet框架</h2><p>一个将相关滤波end2end实现的结构<br>使用siamese fc的框架,不过效果并没有比siamese fc好多少<br>把他当做 siamese fc也完全没问题的,这里就不细讲了</p>
<p><er></er></p>
<h2 id="other-details"><a href="#other-details" class="headerlink" title="other details"></a>other details</h2><ol>
<li>使用6帧的历史信息</li>
<li>使用5个尺度的尺度搜索以及尺度缩放比例为1.025</li>
<li>使用Gaussian Label</li>
<li>使用PNR指标和响应图(reponse map)进行选择性更新模型(稀疏更新)</li>
</ol>
<h3 id="稀疏更新策略"><a href="#稀疏更新策略" class="headerlink" title="稀疏更新策略"></a>稀疏更新策略</h3><p>PNR (peak-versus-noise ratio)定义见下图<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/pnr.jpeg" alt="这里写图片描述"><br>其中R是跟踪模型输出的reponse map<br>当这两个指标超过阈值时更新模型参数<br>其中阈值定义见下图<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/2018CVPR之end2end光流相关滤波/threshold.jpeg" alt="这里写图片描述"> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/14/光流介绍与FlowNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/光流介绍与FlowNet/" itemprop="url">光流介绍与FlowNet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T14:07:56+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CV/" itemprop="url" rel="index">
                    <span itemprop="name">CV</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要由于需求原因,需要了解一些Optical Flow相关知识<br>于是写下这篇入门介绍文章</p>
<h2 id="Optical-Flow-光流-介绍"><a href="#Optical-Flow-光流-介绍" class="headerlink" title="Optical Flow(光流) 介绍"></a>Optical Flow(光流) 介绍</h2><p>segmentation &emsp;: 像素级的分类<br>光流估计 &emsp;&emsp;&emsp; : 像素级的回归</p>
<p>光流估计 &emsp; 预测连续图片序列中每个像素的速度(大小与方向)</p>
<blockquote>
</blockquote>
<p>例如给定第t帧与t+1帧,求每个像素的运动速度与方向<br>I<sub>t</sub>(x<sub>1</sub>,y<sub>1</sub>) = I<sub>t+1</sub>(x<sub>2</sub>,y<sub>2</sub>) = I<sub>t</sub>(x<sub>1</sub> + v<sub>x</sub>,y<sub>1</sub> + v<sub>y</sub>)<br>(v<sub>x</sub>,v<sub>y</sub>)即为我们要预测的</p>
<p>光流场 (Optical Flow Field) : 整张图片的光流</p>
<p>光流场是个双通道图像,尺寸与原图相等</p>
<p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/光流介绍与FlowNet/flow.jpg" alt="这里写图片描述"> </p>
<h2 id="FlowNet"><a href="#FlowNet" class="headerlink" title="FlowNet"></a>FlowNet</h2><h3 id="FlowNetCorr"><a href="#FlowNetCorr" class="headerlink" title="FlowNetCorr"></a>FlowNetCorr</h3><p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/光流介绍与FlowNet/corr.jpg" alt="这里写图片描述"> </p>
<p>如图,网络整体还是很容易理解的<br>灰色箭头是给了一条支路用于concat操作,U-net,densenet等网络中已经屡见不鲜<br>conv_redir是1*1卷积用于压缩至32维</p>
<p>corr定义如下<br>其实就是拿第二个feature map去卷积 (其实是相关运算) 第一个feature map<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/光流介绍与FlowNet/kernel.jpg" alt="这里写图片描述"><br>f1:第一个特征图&emsp;&emsp;f2:第二个特征图<br>x1,x2是位置<br>卷积核尺寸 : 以x<sub>2</sub>为中心的 (2k+1)*(2k+1) 的区域 , 通道与原feature map一致<br>卷积核个数 : 即x<sub>2</sub>可选位置的个数<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;x<sub>2</sub>可取x<sub>1</sub>为中心周围 (2k+1)*(2k+1) 的所有位置<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;论文中k取10,即(2*10+1)*(2*10+1)=441个通道</p>
<h3 id="refinement"><a href="#refinement" class="headerlink" title="refinement"></a>refinement</h3><p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/14/光流介绍与FlowNet/refine.jpg" alt="这里写图片描述"> </p>
<p>主要为堆叠deconv和concat操作<br>其实这部分加上Corr运算之后的部分合起来和Unet没啥区别</p>
<p>其中 flow5/4/3 等是把concat起来的feature map进行预测光流场(conv成双通道再deconv)<br>再和下一个feature map 进行 concat</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>总而言之就是 Corr + U-net + flow<br>模型以实验得出为主<br>也是较早的一个模型,好像flow net 2.0也出来了,主要用于我粗略了解这方面的知识</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/qrfaction/qrfaction.github.io/2018/05/12/2018CVPR之RASNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qrfaction">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qrfaction的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/2018CVPR之RASNet/" itemprop="url">2018CVPR之RASNet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-12T19:58:19+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CV/" itemprop="url" rel="index">
                    <span itemprop="name">CV</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2018的CVPR<br>浏览过五六篇的2018CVPR tracking的工作介绍<br>个人感觉这篇质量还不错<br>自己其实也有很多想法<br>这篇文章让我的想法有了另一种实现方式</p>
<p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/12/2018CVPR之RASNet/model.jpeg" alt="这里写图片描述"> </p>
<h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/12/2018CVPR之RASNet/f.jpeg" alt="这里写图片描述"><br>本质就是给相关运算进行加权运算<br><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/12/2018CVPR之RASNet/f_1.jpeg" alt="这里写图片描述"><br>而加权运算被分解成了三个attention mechanisms进行参数剪枝<br>参数从m<em>n</em>d减少为m*n+d</p>
<er>

<ol>
<li><p>通道注意力β<br>&emsp; &emsp;    (类似SEnet)这个部件今年很多文章都有提到</p>
</li>
<li><p>对偶注意力(dual attention)<br>&emsp; &emsp; (1) general attention<br>&emsp; &emsp;&emsp; &emsp;这个注意力要满足中心位置权重大于周围位置,例如高斯分布<br>&emsp; &emsp;&emsp; &emsp;实际上是使用了target在目标图像的中心位置的先验知识<br>&emsp; &emsp; (2) residual attention<br>&emsp; &emsp;&emsp; &emsp;dual attention = general attention + residual attention<br>&emsp; &emsp;&emsp; &emsp;第一个注意力使用了先验,而第二个注意力用于微修general attention</p>
</li>
</ol>
<p>个人感觉dual attention的机制还是很棒的,一般残差拟合的难度小于整体拟合<br>这里其实还有办法利用一些先验给search area使用attention mechanism<br>这就属于个人idea了hh</p>
<p><er></er></p>
<h3 id="离线预训练"><a href="#离线预训练" class="headerlink" title="离线预训练"></a>离线预训练</h3><p>作者利用ILSVRC15比赛的数据集进行预训练<br>对于每个target 选择target时刻i的图像,以及和时刻j的帧组成一个samples进行加权拟合<br>权重公式如下    时间相差越近,权重越高</p>
<p><img src="https://raw.githubusercontent.com/qrfaction/qrfaction.github.io/master/2018/05/12/2018CVPR之RASNet/w.jpeg" alt="这里写图片描述"> </p>
<p><er></er></p>
<h3 id="details"><a href="#details" class="headerlink" title="details"></a>details</h3><ol>
<li>注意力权重的推断仅在第一帧进行,接下来一直使用同一个注意力权重有助于高速推断</li>
<li>离线预训练中的样本对从相邻的100帧中选取</li>
<li>尺度搜索选择了3个尺度,尺度缩放比例为1.03</li>
</ol>
</er>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">qrfaction</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qrfaction</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
